<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SGL</title>
      <link href="/2023/04/17/papers/sgl/"/>
      <url>/2023/04/17/papers/sgl/</url>
      
        <content type="html"><![CDATA[<h1 id="Self-supervised-Graph-Learning-for-Recommendation"><a href="#Self-supervised-Graph-Learning-for-Recommendation" class="headerlink" title="Self-supervised Graph Learning for Recommendation"></a>Self-supervised Graph Learning for Recommendation</h1><h2 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h2><p>解决目前基于user-item二分图表征学习的推荐系统面临的两大核心问题：</p><ol><li>流行度偏差：高度节点对表征学习的影响较大，恶化了低度项目的推荐</li><li>鲁棒性问题：表征容易受到噪声交互的影响，因为邻域聚合方案进一步扩大了观察到的边缘的影响。</li></ol><h2 id="2-METHODOLOGY"><a href="#2-METHODOLOGY" class="headerlink" title="2. METHODOLOGY"></a>2. METHODOLOGY</h2><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417213410289.png" alt="SGL的整体框架"></p><ul><li>上层说明了主要监督学习任务的工作流程。</li><li>下层显示了经过数据增强的图结构SSL任务工作流程。</li></ul><p>SGL的主要流程是：</p><ol><li><p>数据增强，生成多个视图</p><ul><li>Node Dropout</li></ul><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417215712660.png" alt="" style="zoom:67%;"></p><ul><li>Edge Dropout</li></ul><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417215833682.png" alt="" style="zoom:67%;"></p><ul><li><p>Random Walk</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417215851241.png" alt="" style="zoom:67%;"></p></li></ul><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417221032274.png" alt="3层GCN中ED与RW的例子" style="zoom:67%;"></p></li><li><p>利用图编码，形成不同视图的节点Representation，在这些表征上做对比学习</p><p>InfoNCE Loss</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417215610873.png" alt="" style="zoom:67%;"></p></li><li><p>将传统的监督目标与对比学习监督目标相加，形成多目标学习范式</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417215936196.png" alt="" style="zoom:80%;"></p><p>item侧和user侧是对称的，同理得到item的损失函数，因此最终自监督的损失函数如下：</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417220222285.png" alt="" style="zoom:80%;"></p><p>最终的损失函数：推荐系统常用的BPR-pairwise损失函数自监督结合起来做联合训练</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230417220017621.png" alt="" style="zoom:80%;"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Graph Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph Learning </tag>
            
            <tag> Deep Learning </tag>
            
            <tag> Self-supervised </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三数之和 LC15</title>
      <link href="/2023/04/11/leetcode/san-shu-zhi-he/"/>
      <url>/2023/04/11/leetcode/san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode15-三数之和"><a href="#LeetCode15-三数之和" class="headerlink" title="LeetCode15 三数之和"></a>LeetCode15 三数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先对数组进行排序。第一层是对a的遍历，第二层左指针是对b的遍历，右指针是对c的遍历。</p><p>当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从$O(N^2)$ 减少至$O(N)$</p><p>时间复杂度：$O(N^2)$，<em>N</em> 是数组 $nums$ 的长度</p><p>空间复杂度：$O(logN)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> first <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> first <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> first<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果之前遍历过a 跳过</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>first <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 右指针</span>            <span class="token keyword">int</span> third <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token operator">-</span>nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 左指针</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> second <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> second <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> second<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 如果之前遍历过b 跳过</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>second <span class="token operator">&gt;</span> first <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>second<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>second <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>second<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>third<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target <span class="token operator">&amp;&amp;</span> second <span class="token operator">&lt;</span> third<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    third<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 如果指针重合，随着 b 后续的增加</span>                <span class="token comment">// 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>second <span class="token operator">==</span> third<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>second<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>third<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">{</span>nums<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>second<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>third<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> Medium </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础知识</title>
      <link href="/2023/04/11/ji-qi-xue-xi-ji-chu-zhi-shi/"/>
      <url>/2023/04/11/ji-qi-xue-xi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习基础知识"><a href="#机器学习基础知识" class="headerlink" title="机器学习基础知识"></a>机器学习基础知识</h1><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><h3 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h3><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230411151958668.png" alt="混淆矩阵" style="zoom:80%;"></p><script type="math/tex; mode=display">TPRate=\frac{TP}{TP+FN} \\FPRate=\frac{FP}{FP+TN}</script><ul><li>$TPRate$就是$TP$除以$TP$所在的列，$FPRate$就是$FP$除以$FP$所在的列</li><li>$TPRate$的意义是所有真实类别为1的样本中，预测类别为1的比例。</li><li>$FPRate$的意义是所有真实类别为0的样本中，预测类别为1的比例。</li></ul><h3 id="ROC曲线与AUC"><a href="#ROC曲线与AUC" class="headerlink" title="ROC曲线与AUC"></a>ROC曲线与AUC</h3><p>按照定义，AUC即ROC曲线下的面积，而ROC曲线的横轴是$FPRate$，纵轴是$TPRate$，当二者相等时，即$y=x$，如下图。表示的意义是：对于不论真实类别是1还是0的样本，分类器预测为1的概率是相等的。换句话说，分类器对于正例和负例毫无区分能力。</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230411152427293.png" alt="AUC" style="zoom:67%;"></p><p>而我们希望分类器达到的效果是：对于真实类别为1的样本，分类器预测为1的概率（即$TPRate$），要大于真实类别为0而预测类别为1的概率（即$FPRate$），即$y＞x$，因此大部分的ROC曲线长成下面这个样子：</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230411152645404.png" alt="合理的ROC曲线" style="zoom:67%;"></p><p>最理想的情况下，$TPRate$一直为1，$FPRate$一直为0，AUC为1，这便是AUC的极大值。</p><p>对于硬分类器（例如SVM，NB），预测类别为离散标签，对于8个样本的预测情况如下：</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230411153140055.png" alt="" style="zoom:67%;"></p><p>得到混淆矩阵如下：</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230411153218035.png" alt="" style="zoom:67%;"></p><p>进而算得$TPRate=3/4$，$FPRate=2/4$，得到ROC曲线：</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230411153252381.png" alt="" style="zoom:67%;"></p><p>最终得到AUC为0.625。</p><p>最后说说AUC的优势，AUC的计算方法同时考虑了分类器对于正例和负例的分类能力，在样本不平衡的情况下，依然能够对分类器作出合理的评价。</p><p>例如在反欺诈场景，设欺诈类样本为正例，正例占比很少（假设0.1%），如果使用准确率评估，把所有的样本预测为负例，便可以获得<strong>99.9%的准确率</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛最多水的容器 LC11</title>
      <link href="/2023/04/11/leetcode/sheng-zui-duo-shui-de-rong-qi/"/>
      <url>/2023/04/11/leetcode/sheng-zui-duo-shui-de-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode11-盛最多水的容器"><a href="#LeetCode11-盛最多水的容器" class="headerlink" title="LeetCode11 盛最多水的容器"></a>LeetCode11 盛最多水的容器</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：height = [1,1]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= height[i] &lt;= 10^4</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol><li>初始化：双指针i，j分列水槽左右两端；</li><li>循环收窄： 直至双指针相遇时跳出；<ol><li>更新面积最大值 res ；</li><li><strong>选定两板高度中的短板</strong>，向中间收窄一格；</li></ol></li><li>返回值： 返回面积最大值 res 即可；</li></ol><p>计算公式：$S(i,j)=min(h[i],h[j])×(j−i)$</p><p>时间复杂度：$O(N)$，双指针遍历一边底边宽度</p><p>空间复杂度：$O(1)$，变量占用的额外空间。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> height<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxar <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxar<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                 i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                 j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxar<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>链接：<a href="https://leetcode.cn/problems/container-with-most-water">https://leetcode.cn/problems/container-with-most-water</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> Medium </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长连续序列 LC128</title>
      <link href="/2023/04/10/leetcode/zui-chang-lian-xu-xu-lie/"/>
      <url>/2023/04/10/leetcode/zui-chang-lian-xu-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode128-最长连续序列"><a href="#LeetCode128-最长连续序列" class="headerlink" title="LeetCode128 最长连续序列"></a>LeetCode128 最长连续序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [0,3,7,2,5,8,4,6,0,1]输出：9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><p>0 &lt;= nums.length &lt;= 10^5</p></li><li><p>-109 &lt;= nums[i] &lt;= 10^9</p></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>自认为挺牛逼的思路，LeetCode官方题解</p><p>使用哈希表降重之后，暴力匹配的方法是对于x，看x+1、x+2…是否在哈希表中，但是此时最好的时间复杂度是$O(n^2)$，显然不满足题目要求。</p><p>但分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有x、x+1、x+2…，我们却从x+1、x+2开始匹配，结果肯定不会优于从x开始匹配的答案，因此需要考虑如何避免这个情况。</p><p>由该题特性可知，要枚举的x，如果是最长连续序列，那么x-1一定不能存在于哈希表中，因此我们仅需要判断哈希表是否存在x-1。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> num_set<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            num_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> longestStreak <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> currentStreak <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> currentNum <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>num_set<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断x-1是否存在，如果存在就跳过</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>num_set<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>currentNum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    currentNum <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    currentStreak <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            longestStreak <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>currentStreak<span class="token punctuation">,</span> longestStreak<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>            <span class="token keyword">return</span> longestStreak<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> Medium </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字母异位词分组 LC49</title>
      <link href="/2023/04/10/leetcode/zi-mu-yi-wei-ci-fen-zu/"/>
      <url>/2023/04/10/leetcode/zi-mu-yi-wei-ci-fen-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode49-字母异位词分组"><a href="#LeetCode49-字母异位词分组" class="headerlink" title="LeetCode49 字母异位词分组"></a>LeetCode49 字母异位词分组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组，请你将<code>字母异位词</code>组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]输出: [["bat"],["nat","tan"],["ate","eat","tea"]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: strs = [""]输出: [[""]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: strs = ["a"]输出: [["a"]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= strs.length &lt;= 10^4</li><li>0 &lt;= strs[i].length &lt;= 100</li><li>strs[i] 仅包含小写字母</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>使用哈希表 key存放排序好的string，value存放原先的string组</p><p>时间复杂度：$O(nklogk)$，n是string的个数，k是string的长度。klogk，最快速的排序。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token operator">&amp;</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> hashtable<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>string str<span class="token operator">:</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>            string key <span class="token operator">=</span> str<span class="token punctuation">;</span>            <span class="token function">sort</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            hashtable<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> ans<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> hashtable<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> hashtable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>it <span class="token operator">-&gt;</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> Medium </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动零 LC283</title>
      <link href="/2023/04/08/leetcode/yi-dong-ling/"/>
      <url>/2023/04/08/leetcode/yi-dong-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode283-移动零"><a href="#LeetCode283-移动零" class="headerlink" title="LeetCode283 移动零"></a>LeetCode283 移动零</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: nums = [0]输出: [0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$O(N)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将有序数组转换为二叉搜索树 LC108</title>
      <link href="/2023/04/08/leetcode/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu/"/>
      <url>/2023/04/08/leetcode/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode108-将有序数组转换为二叉搜索树"><a href="#LeetCode108-将有序数组转换为二叉搜索树" class="headerlink" title="LeetCode108 将有序数组转换为二叉搜索树"></a>LeetCode108 将有序数组转换为二叉搜索树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足<code>每个节点的左右两个子树的高度差的绝对值不超过 1</code>的二叉树。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="" style="zoom:67%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>递归求解</strong></p><p>时间复杂度：$O(n)$，n是数组长度</p><p>空间复杂度：$O(logn)$，n是数组长度</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">arrayToBSTHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    TreeNode<span class="token operator">*</span> <span class="token function">arrayToBSTHelper</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">-&gt;</span> right <span class="token operator">=</span> <span class="token function">arrayToBSTHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">-&gt;</span> left <span class="token operator">=</span> <span class="token function">arrayToBSTHelper</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杨辉三角 LC118</title>
      <link href="/2023/04/08/leetcode/yang-hui-san-jiao/"/>
      <url>/2023/04/08/leetcode/yang-hui-san-jiao/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode118-杨辉三角"><a href="#LeetCode118-杨辉三角" class="headerlink" title="LeetCode118 杨辉三角"></a>LeetCode118 杨辉三角</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="" style="zoom:70%;"></p><p><strong>示例 1:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: numRows = 5输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: numRows = 1输出: [[1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>时间复杂度：$O(numRow^2)$。</li><li>空间复杂度：$O(1)$。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">ans</span><span class="token punctuation">(</span>numRows<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numRows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> ans<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/pascals-triangle/">https://leetcode.cn/problems/pascals-triangle/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索插入位置 LC35</title>
      <link href="/2023/04/08/leetcode/sou-suo-cha-ru-wei-zhi/"/>
      <url>/2023/04/08/leetcode/sou-suo-cha-ru-wei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode35-搜索插入位置"><a href="#LeetCode35-搜索插入位置" class="headerlink" title="LeetCode35 搜索插入位置"></a>LeetCode35 搜索插入位置</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p> <strong>示例 1:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: nums = [1,3,5,6], target = 5输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: nums = [1,3,5,6], target = 2输出: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: nums = [1,3,5,6], target = 7输出: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示:</strong></p><ul><li>1 &lt;= nums.length &lt;= 10^4</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>nums为无重复元素的<strong>升序</strong>排列数组</li><li>-10^4 &lt;= target &lt;= 10^4</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度：$O(N)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">searchInsert</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/search-insert-position">https://leetcode.cn/problems/search-insert-position</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文链表 LC234</title>
      <link href="/2023/04/06/leetcode/hui-wen-lian-biao/"/>
      <url>/2023/04/06/leetcode/hui-wen-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode234-回文链表"><a href="#LeetCode234-回文链表" class="headerlink" title="LeetCode234 回文链表"></a>LeetCode234 回文链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="" style="zoom: 80%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = [1,2,2,1]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="" style="zoom:80%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = [1,2]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 10^5]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> set<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            head <span class="token operator">=</span> head <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> set<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Link Prediction Datasets</title>
      <link href="/2023/04/06/link-prediction-dataset/"/>
      <url>/2023/04/06/link-prediction-dataset/</url>
      
        <content type="html"><![CDATA[<h1 id="Link-Prediction-Datasets"><a href="#Link-Prediction-Datasets" class="headerlink" title="Link Prediction Datasets"></a>Link Prediction Datasets</h1><div class="table-container"><table><thead><tr><th>规模</th><th>数据集名称</th><th>节点</th><th>边数</th><th>同质图</th><th>无权</th><th>无向</th></tr></thead><tbody><tr><td>Small</td><td>ogbl-ddi</td><td>4267</td><td>1,334,889</td><td>T</td><td>T</td><td>T</td></tr><tr><td>Small</td><td>ogbl-collab</td><td>235,868</td><td>1,285,465</td><td>T</td><td>T</td><td>T</td></tr><tr><td>Small</td><td>ogbl-biokg</td><td>93773</td><td>5088434</td><td>F</td><td>F</td><td>F</td></tr><tr><td>Medium</td><td>ogbl-ppa</td><td>576,289</td><td>30,326,273</td><td>T</td><td>T</td><td>T</td></tr><tr><td>Medium</td><td>ogbl-citation2</td><td>2,927,963</td><td>30,561,187</td><td>T</td><td>T</td><td>F</td></tr><tr><td>Medium</td><td>ogbl-wikikg2</td><td>2,500,604</td><td>17,137,181</td><td>T</td><td>F</td><td>F</td></tr><tr><td>Medium</td><td>ogbl-vessel</td><td>3,538,495</td><td>5,345,897</td><td>T</td><td>T</td><td>T</td></tr></tbody></table></div><p><a href="http://www-personal.umich.edu/~mejn/netdata/">Network data (umich.edu)</a></p><p><a href="http://vlado.fmf.uni-lj.si/pub/networks/data/">http://vlado.fmf.uni-lj.si/pub/networks/data/</a></p><p><a href="https://ogb.stanford.edu/docs/linkprop/">https://ogb.stanford.edu/docs/linkprop/</a> 有六个标准数据集用作LInk Prediction</p><p><a href="https://ogb.stanford.edu/docs/leader_linkprop/">https://ogb.stanford.edu/docs/leader_linkprop/</a> OGB数据集排行榜</p><ol><li><p>USAir</p><p>1987年美国的航空交通情况 332节点 2126边 无节点属性</p><p><a href="http://vlado.fmf.uni-lj.si/pub/networks/pajek/data/gphs.htm">Graph Files (uni-lj.si)</a></p></li><li><p>Coauthorships in network science</p><p>共同作者网络 1589 节点和 2742 边 无节点属性</p><p><a href="http://www-personal.umich.edu/~mejn/netdata/">Network data (umich.edu)</a></p><p>介绍：<a href="https://studentwork.prattsi.org/infovis/visualization/coauthorship-network-science/">Coauthorship in Network Science – Information Visualization (prattsi.org)</a></p></li><li><p>Political blogs</p><p>美国政治博客之间的超链接网络 有向图 包含1490个结点和19090条边 无节点属性</p><p><a href="http://www-personal.umich.edu/~mejn/netdata/">Network data (umich.edu)</a></p></li><li><p>Yeast</p><p>预测蛋白质的细胞定位位点 无节点属性</p><p><a href="https://archive.ics.uci.edu/ml/datasets/Yeast">https://archive.ics.uci.edu/ml/datasets/Yeast</a></p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230406164418143.png" alt="" style="zoom:50%;"></p></li><li><p>Power</p><p>美国西部各州电网拓扑结构的无向、未加权网络 无节点属性</p><p><a href="http://www-personal.umich.edu/~mejn/netdata/">Network data (umich.edu)</a></p></li><li><p>Rocketfuel</p><p>ISP 拓扑映射 无节点属性</p><p><a href="https://research.cs.washington.edu/networking/rocketfuel/">https://research.cs.washington.edu/networking/rocketfuel/</a></p></li><li><p>E.coli</p><p>336种大肠杆菌蛋白质被分为8类，里面包含蛋白质定位位点 无节点属性</p><p><a href="https://archive.ics.uci.edu/ml/datasets/ecoli">https://archive.ics.uci.edu/ml/datasets/ecoli</a></p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230406170608849.png" alt="" style="zoom:50%;"></p></li><li><p>Cora</p><p><a href="http://www.cs.umd.edu/~sen/lbc-proj/LBC.html">http://www.cs.umd.edu/~sen/lbc-proj/LBC.html</a> </p><p>包含2708篇科学出版物， 5429条边，总共7种类别，引文网络由 5429 个链接组成。有节点属性</p></li><li><p>Citeseer</p><p>包含 3312 份科学出版物，分为六类之一，引文网络由 4732 个链接组成。 有节点属性</p></li><li><p>WebKB</p><p><a href="http://www.cs.cmu.edu/~webkb/">http://www.cs.cmu.edu/~webkb/</a></p><p>包含 877 份科学出版物，分为五类之一，引文网络由 1608 个链接组成。有节点属性</p><p>Wisconsin、Cornell、Texas子集</p></li><li><p>Pubmed</p><p>生物医学方面的论文搜寻以及摘要，包含了19717篇糖尿病相关的科学出版物，这些出版物被分成三个类别。 这些出版物的互相引用网络包含了44338条边。有节点属性</p><p><a href="https://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups">https://archive.ics.uci.edu/ml/datasets/Twenty+Newsgroups</a></p></li><li><p>ogbl-ppa</p><p>576,289Nodes 30,326,273Edges </p><p>蛋白质关系网络 同构 无向、无权的图</p><p><a href="https://ogb.stanford.edu/docs/linkprop/">https://ogb.stanford.edu/docs/linkprop/</a></p></li><li><p>ogbl-ddi</p><p>4,267Nodes 1,334,889Edges </p><p>药物相互作用网络 同构、无权、无图</p><p><a href="https://ogb.stanford.edu/docs/linkprop/">https://ogb.stanford.edu/docs/linkprop/</a></p></li><li><p>ogbl-collab</p><p>235,868Nodes 1,285,465Edges</p><p>无向图 多重图（两点间可能存在多边）</p><p>MAG 索引的作者之间的协作网络的子集</p></li><li><p>ogbl-citation2</p><p>2,927,963Nodes 30,561,187Edges</p><p>有向图 </p><p>从 MAG [1] 中提取的论文子集之间的引用网络</p></li><li><p>ogbl-wikikg2</p><p>维基数据知识库[1]中提取的知识图谱</p><p>2,500,604Nodes 17,137,181Edges</p></li><li><p>ogbl-biokg</p><p>知识图谱 </p><p>93,773Nodes 5,088,434Edges</p><p>疾病（10,687个节点）、蛋白质（17,499个）、药物（10,533个节点）、副作用（9,969个节点）和蛋白质功能（45,085个节点）</p><p>有向边 </p></li><li><p>ogbl-vessel</p><p>整个小鼠大脑的无向、未加权空间图</p><p>3,538,495Nodes 5,345,897Edges</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Link Prediction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Link Prediction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的直径 LC543</title>
      <link href="/2023/04/06/leetcode/er-cha-shu-zhi-jing/"/>
      <url>/2023/04/06/leetcode/er-cha-shu-zhi-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode543-二叉树直径"><a href="#LeetCode543-二叉树直径" class="headerlink" title="LeetCode543 二叉树直径"></a>LeetCode543 二叉树直径</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">    1   / \  2   3 / \     4   5    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度：$O(N)$，其中 N为二叉树的节点数，即遍历一棵二叉树的时间复杂度。</p><p>空间复杂度：$O(height)$其中$height$为二叉树的高度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">diameterOfBinaryTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">depth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">depth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> L <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>node <span class="token operator">-&gt;</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> R <span class="token operator">=</span> <span class="token function">depth</span><span class="token punctuation">(</span>node <span class="token operator">-&gt;</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>L <span class="token operator">+</span> R<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> R<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转二叉树 LC226</title>
      <link href="/2023/04/06/leetcode/fan-zhuan-er-cha-shu/"/>
      <url>/2023/04/06/leetcode/fan-zhuan-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode226-翻转二叉树"><a href="#LeetCode226-翻转二叉树" class="headerlink" title="LeetCode226 翻转二叉树"></a>LeetCode226 翻转二叉树</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:50%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img" style="zoom:50%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：root = [2,1,3]输出：[2,3,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：root = []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度：$O(N)$，其中N为二叉树节点的数目。</p><p>空间复杂度：$O(N)$，使用的空间由递归栈的深度决定。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        root <span class="token operator">-&gt;</span> left <span class="token operator">=</span> right<span class="token punctuation">;</span>        root <span class="token operator">-&gt;</span> right <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表 LC206</title>
      <link href="/2023/04/06/leetcode/fan-zhuan-lian-biao/"/>
      <url>/2023/04/06/leetcode/fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode206-反转链表"><a href="#LeetCode206-反转链表" class="headerlink" title="LeetCode206 反转链表"></a>LeetCode206 反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = [1,2]输出：[2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li>链表中节点的数目范围是 [0, 5000]</li></ul><ul><li>-5000 &lt;= Node.val &lt;= 5000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度：$O(N)$，N是链表长度</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ListNode<span class="token operator">*</span> next <span class="token operator">=</span> curr <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>            curr <span class="token operator">-&gt;</span> next <span class="token operator">=</span> prev<span class="token punctuation">;</span>            prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>            curr <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多数元素 LC169</title>
      <link href="/2023/04/05/leetcode/duo-shu-yuan-su/"/>
      <url>/2023/04/05/leetcode/duo-shu-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode169-多数元素"><a href="#Leetcode169-多数元素" class="headerlink" title="Leetcode169 多数元素"></a>Leetcode169 多数元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p> <strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [3,2,3]输出：3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [2,2,1,1,1,2,2]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5 * 10^4</code></li><li><code>-109 &lt;= nums[i] &lt;= 10^9</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度：$O(n)$，其中 n 是数组 <code>nums</code> 的长度。</p><p>空间复杂度：$O(n)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> counts<span class="token punctuation">;</span>        <span class="token keyword">int</span> majority <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">&gt;</span> cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>                cnt <span class="token operator">=</span> counts<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span>                majority <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> majority<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相交链表 LC160</title>
      <link href="/2023/04/05/leetcode/xiang-jiao-lian-biao/"/>
      <url>/2023/04/05/leetcode/xiang-jiao-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode100"><a href="#LeetCode100" class="headerlink" title="LeetCode100"></a>LeetCode100</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="" style="zoom:50%;"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须保持其原始结构 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="" style="zoom:67%;"></a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at '8'解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="" style="zoom:67%;"></a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at '2'解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="" style="zoom:67%;"></a></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提示：</p><ul><li><p>listA 中节点数目为 <code>m</code></p></li><li><p>listB 中节点数目为 <code>n</code></p></li><li>1 &lt;= m, n &lt;= 3 * 10^4</li><li>1 &lt;= Node.val &lt;= 10^5</li><li>0 &lt;= skipA &lt;= m</li><li>0 &lt;= skipB &lt;= n</li><li>如果 listA 和 listB 没有交点，intersectVal 为 <code>0</code></li><li>如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>哈希集合</p><p>时间复杂度$O(m+n)$，其中<code>m</code>和<code>n</code>是分别是链表<code>headA</code>和<code>headB</code>的长度</p><p>空间复杂度$O(m)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_set <span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">&gt;</span> hashtable<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> headA<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            hashtable<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            temp <span class="token operator">=</span> temp <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            temp <span class="token operator">=</span> temp <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paper List</title>
      <link href="/2023/04/05/paperlist/"/>
      <url>/2023/04/05/paperlist/</url>
      
        <content type="html"><![CDATA[<h1 id="Paper-List"><a href="#Paper-List" class="headerlink" title="Paper List"></a>Paper List</h1><h2 id="1-图方向经典"><a href="#1-图方向经典" class="headerlink" title="1. 图方向经典"></a>1. 图方向经典</h2><ol><li>Kipf T N, Welling M. Semi-supervised classification with graph convolutional networks[J]. arXiv preprint arXiv:1609.02907, 2016.</li><li>Veličković P, Cucurull G, Casanova A, et al. Graph attention networks[J]. arXiv preprint arXiv:1710.10903, 2017.</li><li>Yin Y, Wang Q, Huang S, et al. Autogcl: Automated graph contrastive learning via learnable view generators[C]//Proceedings of the AAAI Conference on Artificial Intelligence. 2022, 36(8): 8892-8900.</li><li>Wang X, Ji H, Shi C, et al. Heterogeneous graph attention network[C]//The world wide web conference. 2019: 2022-2032.</li><li>Wu J, Wang X, Feng F, et al. Self-supervised graph learning for recommendation[C]//Proceedings of the 44th international ACM SIGIR conference on research and development in information retrieval. 2021: 726-735.</li><li>Yu J, Yin H, Xia X, et al. Are graph augmentations necessary? simple graph contrastive learning for recommendation[C]//Proceedings of the 45th International ACM SIGIR Conference on Research and Development in Information Retrieval. 2022: 1294-1303.</li></ol><h2 id="2-链接预测"><a href="#2-链接预测" class="headerlink" title="2. 链接预测"></a>2. 链接预测</h2><ol><li>Cai L, Li J, Wang J, et al. Line graph neural networks for link prediction[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2021, 44(9): 5103-5113.</li><li>Liu X, Li X, Fiumara G, et al. Link prediction approach combined graph neural network with capsule network[J]. Expert Systems with Applications, 2023, 212: 118737.</li><li>Wang H, Yin H, Zhang M, et al. Equivariant and stable positional encoding for more powerful graph neural networks[J]. arXiv preprint arXiv:2203.00199, 2022.</li><li>Chamberlain B P, Shirobokov S, Rossi E, et al. Graph Neural Networks for Link Prediction with Subgraph Sketching[J]. arXiv preprint arXiv:2209.15486, 2022.</li><li>Pan L, Shi C, Dokmanić I. Neural link prediction with walk pooling[J]. arXiv preprint arXiv:2110.04375, 2021.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Link Prediction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph Learning </tag>
            
            <tag> Link Prediction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表 LC141</title>
      <link href="/2023/04/04/leetcode/huan-xing-lian-biao/"/>
      <url>/2023/04/04/leetcode/huan-xing-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode141-环形链表"><a href="#LeetCode141-环形链表" class="headerlink" title="LeetCode141 环形链表"></a>LeetCode141 环形链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：<code>pos</code> 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="" style="zoom: 67%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="" style="zoom:67%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="" style="zoom:67%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：head = [1], pos = -1输出：false解释：链表中没有环。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度$O(N)$，其中N是链表中的节点数</p><p>空间复杂度$O(N)$，其中N是链表中的节点数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_set<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">&gt;</span> hashtable<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            hashtable<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>            head <span class="token operator">=</span> head <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只出现一次的数字 LC136</title>
      <link href="/2023/04/04/leetcode/zhi-chu-xian-yi-ci-de-shu-zi/"/>
      <url>/2023/04/04/leetcode/zhi-chu-xian-yi-ci-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-136-只出现一次的数字"><a href="#LeetCode-136-只出现一次的数字" class="headerlink" title="LeetCode 136 只出现一次的数字"></a>LeetCode 136 只出现一次的数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 非空 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [2,2,1]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2 ：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [4,1,2,1,2]输出：4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3 ：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：nums = [1]输出：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 3 * 10^4</li><li>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</li><li>除了某个元素只出现一次以外，其余每个元素均出现两次。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">singleNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 异或运算</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans <span class="token operator">^=</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票的最佳时机 LC121</title>
      <link href="/2023/04/03/leetcode/mai-mai-gu-piao-de-zui-jia-shi-ji/"/>
      <url>/2023/04/03/leetcode/mai-mai-gu-piao-de-zui-jia-shi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode121-买卖股票的最佳时机"><a href="#LeetCode121-买卖股票的最佳时机" class="headerlink" title="LeetCode121 买卖股票的最佳时机"></a>LeetCode121 买卖股票的最佳时机</h1><p><em>立足当时</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择某一天买入这只股票，并选择在 未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^5</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxPro <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> minprice <span class="token operator">=</span> <span class="token number">1e9</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> price <span class="token operator">:</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxPro <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxPro<span class="token punctuation">,</span> price <span class="token operator">-</span> minprice<span class="token punctuation">)</span><span class="token punctuation">;</span>            minprice <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minprice<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxPro<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最大深度 LC104</title>
      <link href="/2023/04/03/leetcode/er-cha-shu-de-zui-da-shen-du/"/>
      <url>/2023/04/03/leetcode/er-cha-shu-de-zui-da-shen-du/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode104-二叉树的最大深度"><a href="#LeetCode104-二叉树的最大深度" class="headerlink" title="LeetCode104 二叉树的最大深度"></a>LeetCode104 二叉树的最大深度</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">  3 / \9  20  /  \ 15   7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>时间复杂度：$O(N)$，其中N为二叉树节点的个数。</p><p>空间复杂度：$O(height)$，其中height表示二叉树的高度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">https://leetcode.cn/problems/maximum-depth-of-binary-tree</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称二叉树 LC101</title>
      <link href="/2023/04/03/leetcode/dui-cheng-er-cha-shu/"/>
      <url>/2023/04/03/leetcode/dui-cheng-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode101"><a href="#LeetCode101" class="headerlink" title="LeetCode101"></a>LeetCode101</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="" style="zoom:50%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：root = [1,2,2,3,4,4,3]输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg" alt="" style="zoom:50%;"></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：root = [1,2,2,null,3,null,3]输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">check</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>right <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>left<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>right <span class="token operator">&amp;&amp;</span> left<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>right <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token operator">-&gt;</span>val <span class="token operator">==</span> right<span class="token operator">-&gt;</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>left<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> right<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>left<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> right<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的中序遍历 LC94</title>
      <link href="/2023/04/03/leetcode/er-cha-shu-de-zhong-xu-bian-li/"/>
      <url>/2023/04/03/leetcode/er-cha-shu-de-zhong-xu-bian-li/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode94-二叉树的中序遍历"><a href="#LeetCode94-二叉树的中序遍历" class="headerlink" title="LeetCode94 二叉树的中序遍历"></a>LeetCode94 二叉树的中序遍历</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。 </p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：root = [1,null,2,3]输出：[1,3,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：root = []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：root = [1]输出：[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>时间复杂度：$O(N)$，其中 N为二叉树节点的个数</p><p>空间复杂度：$O(N)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> res<span class="token punctuation">;</span>        <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代算法"><a href="#迭代算法" class="headerlink" title="迭代算法"></a>迭代算法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">后续补充<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯 LC70</title>
      <link href="/2023/04/03/leetcode/pa-lou-ti/"/>
      <url>/2023/04/03/leetcode/pa-lou-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode70-爬楼梯"><a href="#LeetCode70-爬楼梯" class="headerlink" title="LeetCode70 爬楼梯"></a>LeetCode70 爬楼梯</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：n = 2输出：2解释：有两种方法可以爬到楼顶。<span class="token list punctuation">1.</span> 1 阶 + 1 阶<span class="token list punctuation">2.</span> 2 阶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：n = 3输出：3解释：有三种方法可以爬到楼顶。<span class="token list punctuation">1.</span> 1 阶 + 1 阶 + 1 阶<span class="token list punctuation">2.</span> 1 阶 + 2 阶<span class="token list punctuation">3.</span> 2 阶 + 1 阶<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度：循环执行N次，每次花费常数的时间代价，故渐进时间复杂度为$O(N)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">climbStairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> climb_ways<span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        climb_ways<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        climb_ways<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            climb_ways<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> climb_ways<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> climb_ways<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> climb_ways<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序链表 LC21</title>
      <link href="/2023/04/03/leetcode/he-bing-liang-ge-you-xu-lian-biao/"/>
      <url>/2023/04/03/leetcode/he-bing-liang-ge-you-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode21-合并两个有序链表"><a href="#LeetCode21-合并两个有序链表" class="headerlink" title="LeetCode21 合并两个有序链表"></a>LeetCode21 合并两个有序链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：l1 = [], l2 = []输出：[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：l1 = [], l2 = [0]输出：[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="迭代求解"><a href="#迭代求解" class="headerlink" title="迭代求解"></a>迭代求解</h3><p>时间复杂度：$O(n+m)$，其中n和m分别为两个链表的长度</p><p>空间复杂度：$O(1)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> preHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> preHead<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token operator">-&gt;</span>val <span class="token operator">&lt;</span> l2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            pre <span class="token operator">=</span> pre<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre<span class="token operator">-&gt;</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> preHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括号 LC20</title>
      <link href="/2023/04/03/leetcode/you-xiao-de-gua-hao/"/>
      <url>/2023/04/03/leetcode/you-xiao-de-gua-hao/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode20-有效的括号"><a href="#LeetCode20-有效的括号" class="headerlink" title="LeetCode20 有效的括号"></a>LeetCode20 有效的括号</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li><p>左括号必须用相同类型的右括号闭合。</p></li><li><p>左括号必须以正确的顺序闭合。</p></li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：s = "()"输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：s = "()[]{}"输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入：s = "(]"输出：false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(∣Σ∣)$，$∣Σ∣$表示字符集的大小</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isValid</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        stack<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> stk<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'['</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">']'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">==</span> <span class="token char">'{'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">'}'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ch <span class="token operator">==</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> ch <span class="token operator">!=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串 LC3</title>
      <link href="/2023/04/03/leetcode/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
      <url>/2023/04/03/leetcode/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode3-无重复字符的最长子串"><a href="#LeetCode3-无重复字符的最长子串" class="headerlink" title="LeetCode3 无重复字符的最长子串"></a>LeetCode3 无重复字符的最长子串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: s = "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: s = "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例 3:</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">输入: s = "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>滑动窗口</strong></p><p>时间复杂度：$O(N)$</p><p>空间复杂度：$O(∣Σ∣)$，$∣Σ∣$表示字符集的大小</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 哈希集合，记录每个字符是否出现过</span>        unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> lookup<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxStr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 左指针向右移动一格，移除一个字符</span>                lookup<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 判断此时第rk+1个字符是否存在于哈希表中，并且没有超出边界</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>lookup<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 不断地移动右指针</span>                lookup<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                right<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> curStr <span class="token operator">=</span> right <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 第 i 到 right 个字符是一个极长的无重复字符子串</span>            maxStr <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxStr<span class="token punctuation">,</span> curStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxStr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> Medium </tag>
            
            <tag> LeetCode100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数相加 LC2</title>
      <link href="/2023/03/26/leetcode/liang-shu-xiang-jia/"/>
      <url>/2023/03/26/leetcode/liang-shu-xiang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode2-两数求和"><a href="#LeetCode2-两数求和" class="headerlink" title="LeetCode2 两数求和"></a>LeetCode2 两数求和</h1><h2 id="基础知识——链表"><a href="#基础知识——链表" class="headerlink" title="基础知识——链表"></a>基础知识——链表</h2><h3 id="1-链表的基本模板"><a href="#1-链表的基本模板" class="headerlink" title="1. 链表的基本模板"></a>1. 链表的基本模板</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Definition for singly-linked list.</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span> <span class="token comment">// 数据域</span>    ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 指数域</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>next<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-创建链表"><a href="#2-创建链表" class="headerlink" title="2. 创建链表"></a>2. 创建链表</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 创建链表</span>ListNode<span class="token operator">*</span> <span class="token function">creation</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode <span class="token operator">*</span>l1_head <span class="token operator">=</span> <span class="token keyword">new</span> ListNode<span class="token punctuation">;</span> <span class="token comment">// 头节点 不存储数据</span>    l1_head <span class="token operator">-&gt;</span> next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token comment">// 指数域指向空</span>    ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> l1_head<span class="token punctuation">;</span> <span class="token comment">// 定义pre，最开始的pre等于l1_head</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 每次循环创建一个新的节点</span>        ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// pre的指数域指向的下一个节点temp，把pre和temp连接起来</span>        pre <span class="token operator">-&gt;</span> next <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment">// 把temp赋给pre，此时的pre就是最后的temp</span>        pre <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> l1_head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-输出链表"><a href="#3-输出链表" class="headerlink" title="3. 输出链表"></a>3. 输出链表</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 输出链表</span><span class="token keyword">void</span> <span class="token function">outputList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1_head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ListNode<span class="token operator">*</span> temp <span class="token operator">=</span> l1_head <span class="token operator">-&gt;</span> next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>temp<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>temp<span class="token operator">-&gt;</span>val<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-主函数"><a href="#4-主函数" class="headerlink" title="4. 主函数"></a>4. 主函数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 生成一个五个节点的链表</span>    ListNode<span class="token operator">*</span> l1_head <span class="token operator">=</span> <span class="token function">creation</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outputList</span><span class="token punctuation">(</span>l1_head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和 LC1</title>
      <link href="/2023/03/26/leetcode/liang-shu-zhi-he/"/>
      <url>/2023/03/26/leetcode/liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode1-两数之和"><a href="#LeetCode1-两数之和" class="headerlink" title="LeetCode1 两数之和"></a>LeetCode1 两数之和</h1><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 $nums$ 和一个整数目标值$target$，请你在该数组中找出和为目标值$target$的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/two-sum">https://leetcode.cn/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230326151410087.png" alt="" style="zoom:80%;"></p><p>利用哈希表，查找x = target - nums[i]，如果此时这个x在哈希表中，证明查找成功。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// unordered_map 无序哈希表    </span>    unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> hashtable<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> it <span class="token operator">=</span> hashtable<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> hashtable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>it<span class="token operator">-&gt;</span>second<span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment">// it-&gt;second是对应的value</span>        <span class="token punctuation">}</span>        <span class="token comment">// key是nums[i]的值</span>        <span class="token comment">// value是数组对应下标</span>        hashtable<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度为$O(N)$</p><p>空间复杂度为$O(N)$</p><h3 id="C-unordered-map容器的成员方法"><a href="#C-unordered-map容器的成员方法" class="headerlink" title="C++ unordered_map容器的成员方法"></a>C++ unordered_map容器的成员方法</h3><div class="table-container"><table><thead><tr><th>begin()</th><th>返回指向容器中第一个键值对的正向迭代器。</th></tr></thead><tbody><tr><td>end()</td><td>返回指向容器中最后一个键值对之后位置的正向迭代器。</td></tr><tr><td>size()</td><td>返回当前容器中存有键值对的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>at(key)</td><td>返回容器中存储的键 key 对应的值，如果 key 不存在，则会抛出 out_of_range 异常。</td></tr></tbody></table></div><p><a href="http://c.biancheng.net/view/7231.html">C++ STL unordered_map容器用法详解 (biancheng.net)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2023/03/26/hello-world/"/>
      <url>/2023/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCN</title>
      <link href="/2023/03/26/gcn/"/>
      <url>/2023/03/26/gcn/</url>
      
        <content type="html"><![CDATA[<h1 id="GCN-图卷积神经网络"><a href="#GCN-图卷积神经网络" class="headerlink" title="GCN 图卷积神经网络"></a>GCN 图卷积神经网络</h1><p><em>无穷的远方，无数的人们，都和我有关。——鲁迅《且介亭杂文末集·这也是生活》</em></p><h2 id="1-将节点映射为d维向量"><a href="#1-将节点映射为d维向量" class="headerlink" title="1. 将节点映射为d维向量"></a>1. 将节点映射为d维向量</h2><p>图神经网络的基本原理是：</p><p><strong>将图中节点编码映射成一个低维连续稠密的d维向量</strong></p><p>d可以为128、256…</p><p>这个向量可以反映在原图的属性关系</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325195204078.png" alt="图1.1 节点映射为d维向量" style="zoom:80%;"></p><h2 id="2-计算图"><a href="#2-计算图" class="headerlink" title="2. 计算图"></a>2. 计算图</h2><h3 id="2-1-通过局部邻域构建计算图"><a href="#2-1-通过局部邻域构建计算图" class="headerlink" title="2.1 通过局部邻域构建计算图"></a>2.1 通过局部邻域构建计算图</h3><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325152228320.png" alt="图2.1.1 计算图" style="zoom:80%;"></p><p>每个节点可以分别构建自己的计算图</p><p>例如图2.1中的图，每个节点对应的计算图如下所示</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325152531870.png" alt="图2.1.2 每个节点对应的计算图" style="zoom:67%;"></p><p>在计算图中，所有的黑色神经网络共享一套参数，所有的白色神经网络共享一套参数。</p><h3 id="2-2-图神经网络层数"><a href="#2-2-图神经网络层数" class="headerlink" title="2.2 图神经网络层数"></a>2.2 图神经网络层数</h3><p><strong>图神经网络的层数，是计算图的层数，而不是神经网络的层数。</strong></p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325152854348.png" alt="图2.2.1 图神经网络的层数" style="zoom:80%;"></p><p>上图的图神经网络层数为2，因为计算图为2层。Layer-1、Layer-2中的神经网络层数可以为任意大小。Layer-0为节点的属性特征，是自带的，无须学习。 </p><p>图神经网络（计算图）可以任意深，但是根据“六度空间”理论，理论上已经可以得到所有信息。</p><p>图神经网络不能无限深，因为会导致所有计算图的节点都很类似，会产生过平滑（over smoothing）问题。所有节点的嵌入都会收敛到同一个值，即所有节点的embedding都相同。因此图神经网络一般两三层就足够了。</p><p>计算图的原理：</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325154822470.png" alt="图2.2.2 两层计算图原理" style="zoom:67%;"></p><p>左图是过程，右图目标节点是最终得到的计算图</p><h3 id="2-3-K层GCC的感受野"><a href="#2-3-K层GCC的感受野" class="headerlink" title="2.3 K层GCC的感受野"></a>2.3 K层GCC的感受野</h3><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325153428719.png" alt="图2.3.1 K层GCC的感受野" style="zoom:80%;"></p><p>1-layer就是目标节点的邻居</p><p>2-layer就是目标节点邻居的邻居</p><p>3-layer就是目标节点邻居的邻居的邻居</p><p><em>层数越多，感受野越大。感受野这个词还是挺形象的</em></p><h3 id="2-4-举个例子"><a href="#2-4-举个例子" class="headerlink" title="2.4 举个例子"></a>2.4 举个例子</h3><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325155341547.png" alt="图2.4.1 无自身信息的图卷积神经网络" style="zoom:80%;"></p><p>每个节点都是128*1的向量</p><p>图卷积神经网络第一层：</p><ul><li>计算B的embedding时，A和C逐元素求平均，得到一个新的128*1维的向量。输入到黑色卷积神经网络中， 输出为512*1维度的向量。</li><li>计算C的embedding，就是计算ABEF的平均，得到128维向量，卷积后输出512维向量。</li><li>D同理。 </li></ul><p>第二层：</p><ul><li>BCD逐元素求平均，得到新的512维的向量，输入到白色卷积神经网络中，最终得到256维A的embedding，作为A节点的输出。</li></ul><h2 id="3-数学形式"><a href="#3-数学形式" class="headerlink" title="3. 数学形式"></a>3. 数学形式</h2><h3 id="3-1-数学公式表示"><a href="#3-1-数学公式表示" class="headerlink" title="3.1 数学公式表示"></a>3.1 数学公式表示</h3><script type="math/tex; mode=display">h_v^{(0)}=x_v \\h_v^{(k+1)}=\alpha(W_k\sum_{u \in N(v)}\frac{h_u^k}{|N(v)|})\\z_v=h_v^K\\</script><ul><li>第0层的属性嵌入就是每个节点的属性特征。</li><li>k+1层v节点的嵌入是由第k层邻域节点u算出来的。其实就是对k层节点求平均后输入到卷积神经网络，经过非线性激活，得到k+1层嵌入。这是一个递归的过程。</li><li>假设这个卷积神经网络只有两层，K=2，就以第二层v节点的z作为最后的输出的embedding。</li></ul><h3 id="3-2-矩阵表示"><a href="#3-2-矩阵表示" class="headerlink" title="3.2 矩阵表示"></a>3.2 矩阵表示</h3><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325164450391.png" alt="图3.2.1 矩阵表示的每一步解释" style="zoom:70%;"></p><ul><li><p>第k层所有的嵌入为$H^{(k)}=[h_1^{(k)}…h_{|V|}^{(k)}]^T$，在这个大矩阵中，每个节点的嵌入就是其中一行。</p></li><li><p>对$H$矩阵左乘一个邻接矩阵A的第v行，也就是$A_vH^{(k)}$，就可以把$v$节点的邻域节点挑出来，得到v节点的embedding。其实也就是求和的过程。</p></li><li><p>求平均的过程：找出一个$D$矩阵（一个对角矩阵）， 每个元素是对应节点的连接数。$D^{-1}AH^{(k)}$中的$D^{-1}$就是求平均的过程。</p></li><li><p>$D^{-1}A$是Row Normalized Matrix，<strong>最大特征值为1</strong>。</p></li></ul><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325170802811.png" alt="图3.2.2 计算$A_{row}$的一个例子" style="zoom:80%;"></p><p>$A_{row}=D^{-1}A$的特点：</p><ul><li>$A_{row}$是一个非对称矩阵</li><li>$A_{col}$和$A_{row}$互为转置</li><li>最大特征值为1</li><li>只按照自己的度，对所有渠道来的信息强行求平均</li><li>没有考虑对方的连接数</li></ul><p><em>因此，使用$D^{-1}A$计算权重不太科学。</em></p><p><strong>最终，我们使用$A_{sym}=D^{-\frac{1}{2}}AD^{-\frac{1}{2}}$</strong></p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325184824963.png" alt="图3.2.3 $D^{-\frac{1}{2}}AD^{-\frac{1}{2}}$对应计算结果" style="zoom:80%;"></p><p><strong>$A_{sym}=D^{-\frac{1}{2}}AD^{-\frac{1}{2}}$的特点：</strong></p><ul><li><strong>$A_{sym}$是一个对称矩阵</strong></li><li><strong>最大特征值为1</strong></li></ul><h3 id="3-3-tilde-A-ij-含义"><a href="#3-3-tilde-A-ij-含义" class="headerlink" title="3.3 $\tilde{A_{ij}}$含义"></a>3.3 $\tilde{A_{ij}}$含义</h3><script type="math/tex; mode=display">\tilde{A_{ij}}=\frac{1}{\sqrt{d_i}\sqrt{d_j}}</script><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325190459336.png" alt="图3.3.1 $\tilde{A_{ij}}$的两种情况" style="zoom:80%;"></p><ul><li>如果i和j直接相连，那么$\tilde{A_{ij}}$为1，此时关联程度较高</li><li>反之，关联程度较低，为$Small\tilde{A_{ij}}$</li></ul><p>$\tilde{A_{ij}}$被称为normalized diffusion matrix，有以下特征：</p><ul><li>在[-1,1]范围之间</li><li>最大值为1</li><li>$A_{sym}$其实就是$\tilde{A_{ij}}$</li><li>稀疏矩阵</li></ul><h3 id="3-4-最终版数学形式"><a href="#3-4-最终版数学形式" class="headerlink" title="3.4 最终版数学形式"></a>3.4 最终版数学形式</h3><script type="math/tex; mode=display">h_v^{(0)}=x_v \\h_v^{(k+1)}=\alpha(D^{-\frac{1}{2}}AD^{-\frac{1}{2}}H^{(k)}W^{(k)})\\z_v=h_v^K\\</script><p>$W^{(k)}$是可学习的参数矩阵</p><p>$D^{-\frac{1}{2}}AD^{-\frac{1}{2}}$无需学习，图一旦确定，该矩阵就已经确定</p><h2 id="4-self-edge的GCN"><a href="#4-self-edge的GCN" class="headerlink" title="4. self edge的GCN"></a>4. self edge的GCN</h2><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325192732450.png" alt="图4.1 有self edge的GCN" style="zoom:80%;"></p><p>添加了self embedding</p><h3 id="4-1-self-edge的数学形式"><a href="#4-1-self-edge的数学形式" class="headerlink" title="4.1 self edge的数学形式"></a>4.1 self edge的数学形式</h3><p>此时的数学形式为</p><script type="math/tex; mode=display">H_i^{(k)}=\alpha(\sum_{j \in \{N(i) \cup i\} }\frac{\tilde{A_{ij}}}{\sqrt{\tilde{D_{ij}}\tilde{D_{ij}}}}H_j^{(k-1)}W^{(k)})\\</script><p>或者可以写为</p><script type="math/tex; mode=display">H_i^{(k)}=\alpha(\sum_{j \in N(i)}\frac{\tilde{A_{ij}}}{\sqrt{\tilde{D_{ij}}\tilde{D_{ij}}}}H_j^{(k-1)}W^{(k)}+\frac{1}{\tilde{D_{ij}}}H_i^{(k-1)}W^{(k)})\\</script><h2 id="5-思考"><a href="#5-思考" class="headerlink" title="5. 思考"></a>5. 思考</h2><h3 id="5-1-半监督节点分类方法"><a href="#5-1-半监督节点分类方法" class="headerlink" title="5.1 半监督节点分类方法"></a>5.1 半监督节点分类方法</h3><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230325194130121.png" alt="图5.1.1 半监督节点分类方法对比" style="zoom:80%;"></p><ol><li>人工特征工程：节点重要度、集群系数、Graphlet等。</li><li>基于随机游走的方法：构造自监督表示学习任务实现图嵌入。无法泛化到新节点。例如: DeepWalk、Node2Vec、LINE、SDNE等。</li><li>标签传播：假设“物以类聚，人以群分”，利用邻域节点类别猜测当前节点类别。无法泛化到新节点。例如: Label Propagation、Iterative Classification、Belief Propagation、Correct &amp; Smooth等。</li><li>图神经网络：利用深度学习和神经网络，构造邻域节点信息聚合计算图，实现节点嵌入和类别预测。可泛化到新节点。例如: GCN、GraphSAGE、GAT、GIN等.</li></ol><h3 id="5-2-图神经网络优点"><a href="#5-2-图神经网络优点" class="headerlink" title="5.2 图神经网络优点"></a>5.2 图神经网络优点</h3><ol><li><strong>深度学习拟合学习能力强</strong>，表示学习得到的嵌入向量质量高</li><li>站在深度学习巨人肩膀上</li><li><strong>归纳式</strong>学习能力Inductive Learning：泛化到新节点、新图</li><li><strong>参数量少</strong>、所有计算图<strong>共享</strong>神经网络</li><li>利用节点<strong>属性特征</strong></li><li>利用节点<strong>标注类别</strong></li><li>可以区分节点<strong>结构功能角色</strong> (桥接、中枢、外围边缘</li><li>只需寥寥几层，就可以让任意两个节点相互影响</li></ol><h3 id="5-3-GCN是直推的还是泛化的？"><a href="#5-3-GCN是直推的还是泛化的？" class="headerlink" title="5.3 GCN是直推的还是泛化的？"></a>5.3 GCN是直推的还是泛化的？</h3><ul><li>在直推的(transductive)的场景下，GCN 的目标是对于一个给定的图（即已经有标记的节点和边），对图中的每个节点进行分类、回归等任务。在这种情况下，GCN 能够从图中已有的标记信息中学习节点的特征，然后将这些特征用于任务中。</li><li>在泛化的(inductive)的场景下，GCN 的目标是从一个训练集中学习一个模型，并将该模型泛化到不同的图上。在这种情况下，GCN 通过从训练集中学习到的节点特征和图结构，生成一个通用的模型，然后将该模型用于新的图中。</li><li>在实践中，有些 GCN 方法只能用于 transductive 的场景，而有些 GCN 方法则能够处理 inductive 的场景。例如，原始的 GCN 模型只能处理 transductive 的场景，而后来的 GraphSAGE 模型则能够处理 inductive 的场景。通常情况下，inductive GCN 模型比 transductive GCN 模型更具有实用价值，因为它们能够泛化到新的、没有见过的图中。</li></ul><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1Hs4y157Ls/?spm_id_from=333.788&amp;vd_source=5cf963abd0f635e31aa9385d489cf581">https://www.bilibili.com/video/BV1Hs4y157Ls/?spm_id_from=333.788&amp;vd_source=5cf963abd0f635e31aa9385d489cf581</a></p><p><a href="https://github.com/TommyZihao/zihao_course/blob/main/CS224W/6-3-GCN.md">https://github.com/TommyZihao/zihao_course/blob/main/CS224W/6-3-GCN.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Graph Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCN </tag>
            
            <tag> Graph Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GRU</title>
      <link href="/2023/03/26/gru/"/>
      <url>/2023/03/26/gru/</url>
      
        <content type="html"><![CDATA[<h1 id="GRU-门控循环单元"><a href="#GRU-门控循环单元" class="headerlink" title="GRU 门控循环单元"></a>GRU 门控循环单元</h1><p><em>RNN无法处理较长数据，所有信息都在隐藏状态中，时间较长时累计状态过多，之前的信息不好做抽取。</em></p><p><strong>GRU思想：不是每个观察值都同等重要</strong></p><p><strong>通过门控单元，选择重要的内容 忘记不重要的内容</strong></p><h2 id="1-门控隐状态"><a href="#1-门控隐状态" class="headerlink" title="1.门控隐状态"></a>1.门控隐状态</h2><p>门控循环单元与普通的循环神经网络之间的关键区别在于： 前者支持隐状态的门控。</p><p>门控循环单元模型有专门的机制来确定应该何时更新隐状态， 以及应该何时重置隐状态。 </p><p><strong>隐状态三种情况：</strong></p><ol><li>如果第一个词元非常重要， 模型将学会在第一次观测之后不更新隐状态。 </li><li>同样，模型也可以学会跳过不相关的临时观测。</li><li>最后，模型还将学会在需要的时候重置隐状态。</li></ol><h3 id="1-1重置门和更新门"><a href="#1-1重置门和更新门" class="headerlink" title="1.1重置门和更新门"></a>1.1重置门和更新门</h3><p>我们把更新门和重置门设计成(0,1)区间中的向量，进行凸组合</p><ul><li><strong>更新门</strong> 能关注的机制 控制“可能还想记住”的过去状态的数量</li><li><strong>重置门（遗忘门）</strong> 能遗忘的机制 控制新状态中有多少个是旧状态的副本</li></ul><p>下图描述门控循环单元中的重置门和更新门的输入， 输入是由当前时间步的输入和前一时间步的隐状态给出。 两个门的输出是由使用sigmoid激活函数的两个全连接层给出。</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230321171826823.png" alt="" style="zoom: 80%;"></p><p>对于时间步$t$，假设输入是一个小批量$X_t \in \mathbb {R} ^{n*d}$ (样本个数$n$，输入个数$d$)，</p><p>上一步时间步的隐状态是 $H_{t-1}\in\mathbb{R}^{n*h}$ （隐藏单元个数$h$）。</p><p>重置门 $R_t\in\mathbb{R}^{n*h}$</p><p>更新门  $Z_t\in\mathbb{R}^{n*h}$ </p><p>计算如下所示：</p><script type="math/tex; mode=display">R_t=\alpha(X_tW_{xr}+H_{t-1}W_{hr}+b_r) \tag{1.1.1} \\ Z_t=\alpha(X_tW_{xz}+H_{t-1}W_{hz}+b_z)</script><p>$W_{xr},W_{xz} \in \mathbb{R}^{d*h}$ </p><p>$W_{hr},W_{hz} \in \mathbb{R}^{h*h}$是权重参数</p><p>$b_r，b_z \in \mathbb{R}^{1*h}$是偏置参数</p><p><strong>在求和过程中会触发广播机制。</strong>同时使用sigmoid函数将输入值转换到区间$(0,1)$</p><h3 id="1-2候选隐状态"><a href="#1-2候选隐状态" class="headerlink" title="1.2候选隐状态"></a>1.2候选隐状态</h3><p>我们将重置门$R_t$与RNN中的常规隐状态更新机制集成，得到在时间步$t$的候选隐状态$\tilde{H}_t \in \mathbb {R}^{n*h}$。</p><script type="math/tex; mode=display">\tilde{H}_t = tanh(X_tW_{xh}+(R_t \odot H_{t-1})W_{hh}+b_h) \tag{1.2.1}</script><p>$W_{xh}\in\mathbb{R}^{d*h}$ </p><p>$W_{hh} \in \mathbb{R}^{h*h}$ 是权重参数</p><p>$b_h \in \mathbb {R}^{1*h}$是偏置项</p><p>符号 $\odot$ 是Hadamard积（按照元素乘积）运算符</p><p>在这里，我们使用tanh非线性激活函数来确保候选隐状态中的值保持在区间$(-1，1)$中。</p><p>与RNN的常规隐状态相比，$(1.2.1)$中的$R_t$和$H_{t-1}$的元素相乘可以减少以往状态的影响。</p><p><strong>每当重置门$R_t$中的项接近1时，我们恢复一个例如RNN的常规隐状态的普通循环神经网络。</strong></p><p><strong>对于重置门$R_t$中所有接近0的项，候选隐状态是以$X_t$作为输入的多层感知机的结果。</strong></p><p>因此，任何预先存在的隐状态都会被重置为默认值。</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230322104641189.png" alt="" style="zoom:67%;"></p><p>上图说明了应用重置门之后的计算流程。</p><h3 id="1-3隐状态"><a href="#1-3隐状态" class="headerlink" title="1.3隐状态"></a>1.3隐状态</h3><p>上述的计算结果只是候选隐状态，我们仍然需要结合更新门$Z_t$的效果。 </p><p><strong>这一步确定新的隐状态$H_t \in \mathbb{R}^{n*h}$在多大程度上来自旧的状态$H_{t-1}$和新的候选状态$\tilde{H}_t$。</strong></p><p><strong>更新门$Z_t$仅需要在$H_{t-1}$和$H_{t}$之间进行按元素的凸组合就可以实现这个目标。</strong> </p><p>这就得出了门控循环单元的最终更新公式：</p><script type="math/tex; mode=display">H_t = Z_t \odot H_{t-1}+(1-Z_t) \odot \tilde{H}_t \tag{1.3.1}</script><p><strong>每当更新门$Z_t$接近1时，模型就倾向只保留旧状态。</strong> </p><p><strong>此时，来自$X_t$的信息基本上被忽略，从而有效地跳过了依赖链条中的时间步$t$。</strong></p><p><strong>相反，当$Z_t$接近0时， 新的隐状态$H_t$就会接近候选隐状态$\tilde{H}_t$。</strong></p><p><strong>这些设计可以帮助我们处理循环神经网络中的梯度消失问题，并更好地捕获时间步距离很长的序列的依赖关系。</strong> </p><p>例如，如果整个子序列的所有时间步的更新门都接近于1，则无论序列的长度如何，在序列起始时间步的旧隐状态都将很容易保留并传递到序列结束。</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230322110327072.png" alt="" style="zoom:80%;"></p><p>上图说明了更新门起作用后的计算流。</p><h2 id="2-特征"><a href="#2-特征" class="headerlink" title="2.特征"></a>2.特征</h2><p>GRU有以下俩个显著特征：</p><ul><li><strong>重置门有助于捕获序列中的短期依赖关系</strong></li><li><strong>更新门有助于捕获序列中的长期依赖关系</strong></li></ul><h2 id="3-参考网站"><a href="#3-参考网站" class="headerlink" title="3.参考网站"></a>3.参考网站</h2><p><a href="https://www.bilibili.com/video/BV1mf4y157N2/?spm_id_from=333.999.0.0&amp;vd_source=5cf963abd0f635e31aa9385d489cf581">https://www.bilibili.com/video/BV1mf4y157N2/?spm_id_from=333.999.0.0&amp;vd_source=5cf963abd0f635e31aa9385d489cf581</a></p><p><a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/gru.html#id4">https://zh-v2.d2l.ai/chapter_recurrent-modern/gru.html#id4</a></p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRU </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSTM</title>
      <link href="/2023/03/26/lstm/"/>
      <url>/2023/03/26/lstm/</url>
      
        <content type="html"><![CDATA[<h1 id="LSTM-长短期记忆网络"><a href="#LSTM-长短期记忆网络" class="headerlink" title="LSTM 长短期记忆网络"></a>LSTM 长短期记忆网络</h1><p><strong>长期以来，隐变量模型存在着长期信息保存和短期输入缺失的问题。</strong> </p><p>解决这一问题的最早方法之一是长短期存储器（long short-term memory，LSTM）。</p><h2 id="1-实现效果"><a href="#1-实现效果" class="headerlink" title="1. 实现效果"></a>1. 实现效果</h2><ul><li><p>忘掉过去状态，尽量去看现在的输入数据</p></li><li><p>不看现在的输入数据，尽量去看前一个的状态</p></li></ul><h2 id="2-模型组成"><a href="#2-模型组成" class="headerlink" title="2. 模型组成"></a>2. 模型组成</h2><h3 id="2-1门控记忆单元"><a href="#2-1门控记忆单元" class="headerlink" title="2.1门控记忆单元"></a>2.1门控记忆单元</h3><p>可以说，长短期记忆网络的设计灵感来自于计算机的逻辑门。</p><p>长短期记忆网络引入了<strong>记忆元</strong>，或简称为单元（cell）。有些文献认为记忆元是隐状态的一种特殊类型，它们与隐状态具有相同的形状，其<strong>设计目的是用于记录附加的信息</strong>。</p><p>为了控制记忆元，我们需要许多门。<strong>其中一个门用来从单元中输出条目，我们将其称为输出门（output gate）。另外一个门用来决定何时将数据读入单元，我们将其称为输入门（input gate）。</strong></p><p>我们还需要一种机制来<strong>重置单元的内容，由遗忘门（forget gate）来管理</strong>， 这种设计的动机与门控循环单元相同，能够通过专用机制决定什么时候记忆或忽略隐状态中的输入。</p><ul><li><p>遗忘门：将值朝0减少</p></li><li><p>输入门：决定不是忽略掉输入数据</p></li><li><p>输出门：决定是不是使用隐状态</p></li></ul><h3 id="2-2输入门、忘记门和输出门"><a href="#2-2输入门、忘记门和输出门" class="headerlink" title="2.2输入门、忘记门和输出门"></a>2.2输入门、忘记门和输出门</h3><p>就如在门控循环单元中一样， 当前时间步的输入和前一个时间步的隐状态作为数据送入长短期记忆网络的门中， 如图所示。它们由三个具有sigmoid激活函数的全连接层处理，以计算输入门、遗忘门和输出门的值。因此，这三个门的值都在(0,1)的范围内。</p><p><img src="http://yanhaoli-images.oss-cn-beijing.aliyuncs.com/img/image-20230322113226798.png" alt="" style="zoom:80%;"></p><p><strong>长短期记忆网络的数学表达。</strong></p><p>假设有$ℎ$个隐藏单元，批量大小为$n$，输入数为$d$。 </p><p>输入为$X_t \in \mathbb {R}^{n*d}$</p><p>前一时间步的隐状态为$H_{t-1} \in \mathbb {R}^{n*h}$。 </p><p>相应地，时间步$t$的门被定义如下：</p><p>输入门是$I_t \in \mathbb {R}^{n*h}$ </p><p>遗忘门是$F_t \in \mathbb {R}^{n*h}$</p><p> 输出门是$O_t \in \mathbb {R}^{n*h}$。</p><p>它们的计算方法如下：</p><script type="math/tex; mode=display">I_t=\alpha(X_tW_{xi}+H_{t-1}W_{hi}+b_i)\\F_t=\alpha(X_tW_{xf}+H_{t-1}W_{hf}+b_f)\\O_t=\alpha(X_tW_{xo}+H_{t-1}W_{ho}+b_o)\\ \tag{2.2.1}</script>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
